#PATHS
export PATH="/usr/local/bin:$PATH"
export PATH="/usr/local/opt/postgresql@16/bin:$PATH"
export PATH="/sbin:/usr/sbin:$PATH"
export PATH="/Applications/Docker.app/Contents/Resources/bin:$PATH"
export PATH="$HOME/.local/bin:$PATH"
export PATH="/usr/local/sbin:$PATH"
export PATH="/usr/local/opt/postgresql@17/bin:$PATH"
export PATH="$HOME"/tsunami-udp/tsunami-udp/client/:"$PATH"
export PATH="$HOME"/tsunami-udp/tsunami-udp/server/:"$PATH"



#EDITOR
export VISUAL=nvim
export EDITOR=nvim

#EVALS
case "$SHELL" in
  */bash) eval "$(direnv hook bash)" ;;
  */zsh) eval "$(direnv hook zsh)" ;;
  *)
    echo "[$(date +'%Y-%m-%d %H:%M:%S')] ERROR: unsupported shell '$SHELL'"
    return
    ;;
  esac

eval "$(starship init zsh)"

#Shell
lsa() {
  ls -al "$@"
}

dc() {
  cd ..
}

cd_here () {
        if [ $# -eq 0 ]
        then
                __cd_here_pwd="$(pwd)"
                cd / || return $?
                cd "${__cd_here_pwd}" || return $?
        else
                echo_date "'cd_here' accepts no arguments" && return 1
        fi
}


# echo
echo_date() { echo "[$(date +'%Y-%m-%d %H:%M:%S')] $*"; }


#GITHUB
gs() {
  git status
}

ga() {
  git add -u
}

gc() {
 git commit -m "Saved at $(date +"%Y-%m-%d %H:%M:%S (%a)")"
}

gac() {
  git add -u
  git commit -m "Saved at $(date +"%Y-%m-%d %H:%M:%S (%a)")"
}


gacp() { 
  git add -u
  git commit -m "Saved at $(date +"%Y-%m-%d %H:%M:%S (%a)")"
  git push -u origin "$(git rev-parse --abbrev-ref HEAD)"
} 
gacpf() { 
  git add -u
  git commit -m "Saved at $(date +"%Y-%m-%d %H:%M:%S (%a)")"
  git push -fu origin "$(git rev-parse --abbrev-ref HEAD)"
} 
grbom() {
  git fetch
  git rebase origin/master
}

gp() {
  git push -u origin "$(git rev-parse --abbrev-ref HEAD)"
}

gpf() {
  git push -fu origin "$(git rev-parse --abbrev-ref HEAD)"
}

grb() {
		unset __grb_branch
		if [ $# -eq 0 ]; then
			__grb_branch='origin/master'
		elif [ $# -eq 1 ]; then
			__grb_branch="$1"
		else
			echo "'grb' accepts [0..1] arguments" || return 1
		fi
		git fetch --all || return $?
		git rebase -s recursive -X theirs "${__grb_branch}" || return $?
	}

grbc() {
  git rebase --continue
        }



ns() {
  nvim $HOME/dotfiles/.common
}

ss() {
  source $HOME/dotfiles/.common
}


dot() {
  cd $HOME/dotfiles
}

infiles() {
  cd $HOME/infiles
}

#QRT

qrt() {
  cd $HOME/qrt
}

qrt2() {
  cd $HOME/qrt2
}

installvms() {
  $HOME/qrt/qrt-addons/install-vm.sh debian1 debian1 1234 2224 && $HOME/qrt/qrt-addons/install-vm.sh debian2 debian3 1234 2226 && $HOME/qrt/qrt-addons/install-vm.sh debian3 debian3 1234 2228
}

suvm1sr() {
  $HOME/qrt/scripts/setup-vm.sh debian1 127.0.0.1 debian1 1234 -p 2224 -sr
}

suvm2sr() {
  $HOME/qrt/scripts/setup-vm.sh debian2 127.0.0.1 debian2 1234 -p 2226 -sr
}

suvm3sr() {
  $HOME/qrt/scripts/setup-vm.sh debian3 127.0.0.1 debian3 1234 -p 2228 -sr
}

suvm1() {
  $HOME/qrt/scripts/setup-vm.sh debian1 127.0.0.1 debian1 1234 -p 2224
}

suvm2() {
  $HOME/qrt/scripts/setup-vm.sh debian2 127.0.0.1 debian2 1234 -p 2226
}

suvm3() {
  $HOME/qrt/scripts/setup-vm.sh debian3 127.0.0.1 debian3 1234 -p 2228
}

qrts() {
  nano $HOME/qrt/assets/environment/settings.sh
}

dock() {
  docker exec -it ib-qrt bash
}

jl () {
        if [ $# -eq 0 ]
        then
                uv run --with=altair,beartype,hvplot,jupyterlab,jupyterlab-code-formatter,matplotlib,rich,vegafusion,vegafusion-python-embed,vl-convert-python --active --managed-python jupyter lab || return $?
        else
                echo_date "'jl' accepts no arguments" && return 1
        fi
}

jlnb () {
    if [ $# -eq 0 ]; then
        uv run \
            --with=altair,beartype,hvplot,jupyterlab,jupyterlab-code-formatter,matplotlib,rich,vegafusion,vegafusion-python-embed,vl-convert-python \
            --active --managed-python \
            jupyter lab --no-browser --port=8888 || return $?
    else
        echo_date "'jlnb' accepts no arguments" && return 1
    fi
}

checkout() {
  ~/qrt/scripts/checkout-version.sh
}

__file="${HOME}/common.local.sh"
if [ -f "$__file" ]; then
    . "$__file"
fi


autoload -U compinit; compinit

# tsunami
tsunami_dl() {
    echo -e "set rate 70M \nset speedup 9/10 \nset slowdown 10/9\nset blocksize 1200\nset error 10%\nconnect $(dig +short "$1")\nget *\nquit\n" | tsunami
    }


# tailscale
if command -v tailscale >/dev/null 2>&1 && command -v tailscaled >/dev/null 2>&1; then
	ts_up() {
		if [ $# -eq 0 ]; then
			ts_down || return $?
			__ts_up_auth_key="${HOME}/tailscale.local.sh"
			if ! [ -f "${__ts_up_auth_key}" ]; then
				echo_date "'${__ts_up_auth_key}' does not exist" && return 1
			fi
			if [ -z "${TAILSCALE_LOGIN_SERVER}" ]; then
				echo_date "'\$TAILSCALE_LOGIN_SERVER' does not exist" && return 1
			fi
			echo_date "Starting 'tailscaled' in the background..." || return $?
			sudo tailscaled &
			echo_date "Starting 'tailscale'..." || return $?
			sudo tailscale up --accept-dns --accept-routes --auth-key="file:${__ts_up_auth_key}" --login-server="${TAILSCALE_LOGIN_SERVER}" && return $?
		else
			echo_date "'ts_up' accepts no arguments" && return 1
		fi
	}
	ts_down() {
		if [ $# -eq 0 ]; then
			echo_date "Cleaning 'tailscaled'..." || return $?
			sudo tailscaled --cleanup
			echo_date "Killing 'tailscaled'..." || return $?
			sudo pkill tailscaled
			echo_date "Logging out of 'tailscale'..." || return $?
			sudo tailscale logout
			return 0
		else
			echo_date "'ts_down' accepts no arguments" && return 1
		fi
	}
	ts_status() {
		if [ $# -eq 0 ]; then
			tailscale status
		else
			echo_date "'ts_status' accepts no arguments" && return 1
		fi
	}
	if command -v watch >/dev/null 2>&1; then
		wts_status() {
			if [ $# -eq 0 ]; then
				watch --color --differences --interval=0.5 -- tailscale status
			else
				echo_date "'wts_status' accepts no arguments" && return 1
			fi
		}
	fi
fi
